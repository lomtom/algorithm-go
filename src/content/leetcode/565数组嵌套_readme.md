---
title: 565数组嵌套
categories:
  - 中等
tags:
  - 数组
---

**题目难度：**[数组嵌套](https://leetcode.cn/problems/array-nesting/) 中等

**题目描述：**

> 索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到最大的集合S并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... }且遵守以下的规则。
>
> 假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]... 以此类推，不断添加直到S出现重复的元素。


**测试用例：**

> 示例 1:
>
> 输入: A = [5,4,0,3,1,6,2]
> 
> 输出: 4
> 
> 解释:
> 
> A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

> 其中一种最长的 S[K]:
> 
> S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}

**限制及提示：**
> - N是[1, 20,000]之间的整数。
> - A中不含有重复的元素。
> - A中的元素大小在[0, N-1]之间。

---
**解题分析及思路：**

因为对于数组A存在的元素，是从0到N，并且元素不重复。

所以我们得知在这个数组中必然存在多个环组成，那么我们只需找到最大的环的节点个数即可。

使用一个数组记录当前节点是否被访问。
```go
vis := make([]bool, len(nums))
```

从下标为0开始遍历，访问到的位置标记为已访问，下次访问到该位置时，停止访问，代表环已经闭合。

并且，每次环结束时，将访问到的更大环的结果保存到`ans`中。
```go
for index := range nums {
    res := 0
    for !vis[index] {
        res++
        vis[index] = true
        index = nums[index]
    }
    if res > ans {
		ans = res
    }
}
```

[源代码](https://github.com/lomtom/algorithm-go/blob/main/leetcode/565数组嵌套_test.go)

**复杂度：**
- 时间复杂度：O(n)，排序所需时间
- 空间复杂度：O(n)，排序所需空间

**执行结果：**

- 行用时： 92 ms , 在所有 Go 提交中击败了 96.83% 的用户
- 内存消耗： 8.4 MB , 在所有 Go 提交中击败了 87.30% 的用户
