---
title: 寻找旋转排序数组中的最小值
categories:
  - 中等
tags: 
  - 数组
  - 二分查找
slug: find-minimum-in-rotated-sorted-array
number: 153
---

## 题目描述：

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 3 次得到输入数组。

```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。

```

**提示：**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转

---
## 解题分析及思路：

### 方法：二分查找

**思路：**

在一组数中找到某一个数，并且要求时间复杂度为 O(log n)。那么我们可以采用二分查找的方法。

那么犹豫 `nums` 数组的特殊性，因为其是升序排序的数组精过旋转得到的，那么针对中间下标`mid`，存在两种情况：

- `nums[mid] < nums[r]`，那么 `nums[mid]` 及往右的数都是递增的，并且在`[mid, r]`这些数中，`nums[mid]`是最小值，那么最小值可能是`nums[mid]`，或者 `nums[mid]` 之前的数，因此，我们可以将 `r` 移动到 `mid` ，继续判断。
- `nums[mid] >= nums[r]`，那么 `nums[mid]` 及往左的数都是递增的，并且在`[l, mid]`这些数中，`nums[mid]`是最大值，那么最小值是 `nums[mid]` 之后的数，因此，我们可以将 `l` 移动到 `mid` 右边，继续判断。

直到找到到最小值，返回即可。


```go
func findMin(nums []int) int {
	var l, r = 0, len(nums) - 1
	for l < r {
		mid := (l + r) >> 1
		if nums[mid] < nums[r] {
			r = mid
		} else {
			l = mid + 1
		}
	}
	return nums[l]
}
```

**复杂度：**

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

**执行结果：**

- 执行耗时:0 ms,击败了100.00% 的Go用户
- 内存消耗:2.4 MB,击败了99.83% 的Go用户
