---
title: 买票需要的时间
categories:
  - 简单
tags: 
  - 队列
  - 数组
  - 模拟
slug: time-needed-to-buy-tickets
number: 2073
---

## 题目描述：

有 `n` 个人前来排队买票，其中第 `0` 人站在队伍 **最前方** ，第 `(n - 1)` 人站在队伍 **最后方** 。

给你一个下标从 **0** 开始的整数数组 `tickets` ，数组长度为 `n` ，其中第 `i` 人想要购买的票数为 `tickets[i]` 。

每个人买票都需要用掉 **恰好 1 秒** 。一个人 **一次只能买一张票** ，如果需要购买更多票，他必须走到  **队尾** 重新排队（ **瞬间** 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 **离开** 队伍。

返回位于位置 `k`（下标从 **0** 开始）的人完成买票需要的时间（以秒为单位）。

**示例 1：**

```
输入： tickets = \[2,3,2\], k = 2
输出： 6
解释：
- 队伍一开始为 \[2,3,2\]，第 k 个人以下划线标识。
- 在最前面的人买完票后，队伍在第 1 秒变成 \[3,2,1\]。
- 继续这个过程，队伍在第 2 秒变为\[2,1,2\]。
- 继续这个过程，队伍在第 3 秒变为\[1,2,1\]。
- 继续这个过程，队伍在第 4 秒变为\[2,1\]。
- 继续这个过程，队伍在第 5 秒变为\[1,1\]。
- 继续这个过程，队伍在第 6 秒变为\[1\]。第 k 个人完成买票，所以返回 6。
```
**示例 2：**

```
输入： tickets = \[5,1,1,1\], k = 0
输出： 8
解释：
- 队伍一开始为 \[5,1,1,1\]，第 k 个人以下划线标识。
- 在最前面的人买完票后，队伍在第 1 秒变成 \[1,1,1,4\]。
- 继续这个过程 3 秒，队伍在第 4 秒变为\[4\]。
- 继续这个过程 4 秒，队伍在第 8 秒变为\[\]。第 k 个人完成买票，所以返回 8。
```
**提示：**

- `n == tickets.length`
- `1 <= n <= 100`
- `1 <= tickets[i] <= 100`
- `0 <= k < n`

---
## 解题分析及思路：

### 方法：模拟

**思路：**


在满足第 `k` 位置的人买完票的前提下，计算每个人买票所需要花费的时间。

- 在 `k` 位置之前，如果 `i <= k` ，则 `min(tickets[i], tickets[k])` 为 `i` 位置买票所需要的时间，因为 `i` 位置可以买 `tickets[i]` 张票，而在`k` 位置买完票之前 `i` 位置买票之多只能买 ` tickets[k]` 张票，所以 `min(tickets[i], tickets[k])` 为 `i` 位置买票所需要的时间。
- 在 `k` 位置之后，如果 `i > k` ，则 `min(tickets[i], tickets[k]-1)` 为 `i` 位置买票所需要的时间，因为 `i` 位置可以买 ` tickets[i]` 张票，而在 `k` 位置买完票之前 `i` 位置买票之多只能买 ` tickets[k]-1` 张票，所以 `min(tickets[i], tickets[k]-1)` 为 `i` 位置买票所需要的时间。

最后累计所有时间，返回即可。

```go
func timeRequiredToBuy(tickets []int, k int) int {
	var ans int = 0
	for i := 0; i < len(tickets); i++ {
		if i <= k {
			ans += min(tickets[i], tickets[k])
		} else {
			ans += min(tickets[i], tickets[k]-1)
		}
	}
	return ans
}
```


**复杂度：**

- 时间复杂度：O(n)
- 空间复杂度：O(1)

**执行结果：**

- 执行耗时:0 ms,击败了100.00% 的Go用户
- 内存消耗:2.1 MB,击败了100.00% 的Go用户
