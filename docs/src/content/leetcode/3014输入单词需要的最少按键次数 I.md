---
title: 输入单词需要的最少按键次数 I
categories:
  - 简单
tags:
  - 贪心
  - 数学
  - 字符串
slug: minimum-number-of-pushes-to-type-word-i
number: 3014
---

## 题目描述：

给你一个字符串 word，由 不同 小写英文字母组成。

电话键盘上的按键与 不同 小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 2 对应 ["a","b","c"]，我们需要按一次键来输入 "a"，按两次键来输入 "b"，按三次键来输入 "c"。

现在允许你将编号为 2 到 9 的按键重新映射到 不同 字母集合。每个按键可以映射到 任意数量 的字母，但每个字母 必须 恰好 映射到 一个 按键上。你需要找到输入字符串 word 所需的 最少 按键次数。

返回重新映射按键后输入 word 所需的 最少 按键次数。

下面给出了一种电话键盘上字母到按键的映射作为示例。注意 1，*，# 和 0 不 对应任何字母。

![](/img/leetcode/3014输入单词需要的最少按键次数I/keypaddesc.png)

**示例 1：**
![](/img/leetcode/3014输入单词需要的最少按键次数I/keypadv1e1.png)
```
输入：word = "abcde"
输出：5
解释：图片中给出的重新映射方案的输入成本最小。
"a" -> 在按键 2 上按一次
"b" -> 在按键 3 上按一次
"c" -> 在按键 4 上按一次
"d" -> 在按键 5 上按一次
"e" -> 在按键 6 上按一次
总成本为 1 + 1 + 1 + 1 + 1 = 5 。
可以证明不存在其他成本更低的映射方案。
```

**示例 2：**
![](/img/leetcode/3014输入单词需要的最少按键次数I/keypadv1e2.png)
```
输入：word = "xycdefghij"
输出：12
解释：图片中给出的重新映射方案的输入成本最小。
"x" -> 在按键 2 上按一次
"y" -> 在按键 2 上按两次
"c" -> 在按键 3 上按一次
"d" -> 在按键 3 上按两次
"e" -> 在按键 4 上按一次
"f" -> 在按键 5 上按一次
"g" -> 在按键 6 上按一次
"h" -> 在按键 7 上按一次
"i" -> 在按键 8 上按一次
"j" -> 在按键 9 上按一次
总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。
可以证明不存在其他成本更低的映射方案。
```

**提示：**
- 1 <= word.length <= 26
- word 仅由小写英文字母组成。
- word 中的所有字母互不相同。

---
## 解题分析及思路：

**思路：**

由于按键与字母有一定的映射关系，而按键 2- 9 一共含有 8 个按键，并且word的长度最大为 26 并且不重复，所以可以直接通过长度来计算按键次数。

- 当 word 长度小于等于 8 时，将每个字母映射到一个按键上，所以按键次数为 word 长度。
- 当 word 长度大于 8 且小于等于 16 时，由于 前8个已经占用了按键数为1的位置，所以剩下的按键数为2的位置，所以按键次数为 2*word 长度 - 8。
- 当 word 长度大于 16 且小于等于 24 时，由于 前16个已经占用了按键数为1和2的位置，所以剩下的按键数为3的位置，所以按键次数为 3*word 长度 - 24。
- 当 word 长度大于 24 时，由于 前24个已经占用了按键数为1、2和3的位置，所以剩下的按键数为4的位置，所以按键次数为 4*word 长度 - 48。

```go
func minimumPushes(word string) int {
	l := len(word)
	if l <= 8 {
		return l - 0
	}
	if l <= 16 {
		return 2*l - 8
	}
	if l <= 24 {
		return 3*l - 24
	}
	return 4*l - 48
}
```

**复杂度：**

- 时间复杂度：O(1)
- 空间复杂度：O(1)

**执行结果：**

- 执行耗时:2 ms,击败了22.43% 的Go用户
- 内存消耗:1.9 MB,击败了81.31% 的Go用户

