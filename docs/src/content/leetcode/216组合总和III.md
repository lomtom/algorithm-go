---
title: 组合总和III
categories:
  - 中等
tags:
  - 回溯
  - 数组
slug: combination-sum-iii
number: 40
---

## 题目描述：

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 最多使用一次

返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

**示例 1：**
```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

**示例 2：**
```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

**示例 3：**
```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```

**提示：**
- 2 <= k <= 9
- 1 <= n <= 60

---
## 解题分析及思路：

### 方法：回溯

**思路：**

该题为 [40. 组合总和II](/leetcode/combination-sum-ii) 的进阶版，区别就是从数组换成数组，而且答案的个数固定。

那么只需要按照原有的逻辑，进行裁剪即可。

也就是说，当个数等于k个的时候，才将结果加入到结果集中。


```go
func combinationSum3(k int, n int) (result [][]int) {
	var dfs func(index, sub int, res []int)
	dfs = func(index, sub int, res []int) {
		if sub == 0 && k == 0 {
			result = append(result, append([]int{}, res...))
			return
		}
		for i := index; i <= 9; i++ {
			if k > 0 && sub-i >= 0 {
				res = append(res, i)
				k--
				dfs(i+1, sub-i, res)
				res = res[:len(res)-1]
				k++
			}
		}
	}
	dfs(1, n, []int{})
	return result
}
```

**复杂度：**

- 时间复杂度：O(O(2^n * n))
- 空间复杂度：O(N)

**执行结果：**

- 执行耗时:2 ms,击败了59.02% 的Go用户
- 内存消耗:2.0 MB,击败了13.74% 的Go用户

